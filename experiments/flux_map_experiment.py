import numpy as np
import matplotlib.pyplot as plt

from experiments.experiment import Experiment
from experiments.plotter import Plotter
from instruments import znb, anapico, yoko7651
from instruments.configs.znb_config import ZnbLinConfig, ZnbSegmConfig
from instruments.configs.yoko7651_config import YokoCurrSweepConfig, YokoVoltSweepConfig

from dataclasses import dataclass, asdict, replace
from typing import Union,Type, Tuple, Optional

from time import sleep

from experiments.experiment_data import FluxMapData
from experiments.experiment_config import FluxMapConfig

from experiments.utils import S_to_dBm

import datetime


class FluxMapExperiment(Experiment):

    config: FluxMapConfig
    data: FluxMapData
    measurement_code: str = 'FM'


    def __init__(self, sample_name: str, sample_code: str, file_directory: str, config: FluxMapConfig, file_name: str = None):

        super().__init__(sample_name=sample_name,
                         sample_code=sample_code,
                         measurement_code=self.measurement_code,
                         file_directory=file_directory,
                         file_name=file_name,
                         config=config)
        
        self.data = self.initialize_data()
        self.plotter = Plotter()


    # def end_experiment(self):
    #     plt.close(self.plotter.pcolor_fig)
    #     #self.plot_results()
    #     super().end_experiment()


    def plot_results(self):
        self.plotter.plot_flux_map(self.data, title=f'Flux Map {self.file_name}')


    def initialize_instruments(self):
        self.initialize_vna()
        self.initialize_yoko()



    def initialize_data(self) -> FluxMapData:
        # Initialize stuff if needed
       
        # Create and return an instance of FluxMapData
        return FluxMapData()

    def initialize_flux_map_data(self) -> FluxMapData:
        # Initialize the arrays with appropriate shapes and data types
        currents = np.full(self.config.yoko.sweep_length, np.nan, dtype=np.float64)
        f = np.full(self.config.vna.num_points, np.nan, dtype=np.float64)
        S = np.full((self.config.yoko.sweep_length, self.config.vna.num_points), np.nan, dtype=np.complex128)

        # Create and return an instance of FluxMapData
        return FluxMapData(currents=currents, f=f, S=S)
    
    def initialize_flux_map_voltage_sweep_data(self) -> FluxMapData:
        # Initialize the arrays with appropriate shapes and data types
        voltages = np.full(self.config.yoko.sweep_length, np.nan, dtype=np.float64)
        f = np.full(self.config.vna.num_points, np.nan, dtype=np.float64)
        S = np.full((self.config.yoko.sweep_length, self.config.vna.num_points), np.nan, dtype=np.complex128)

        # Create and return an instance of FluxMapData
        return FluxMapData(voltages=voltages, f=f, S=S)
    
    def initialize_power_sweep_data(self) -> FluxMapData:
        # Initialize the arrays with appropriate shapes and data types
        currents = np.full(self.config.yoko.sweep_length, np.nan, dtype=np.float64)
        powers = np.full(self.config.vna.power_sweep_length, np.nan, dtype=np.float64)

        f = np.full(self.config.vna.num_points, np.nan, dtype=np.float64)
        S = np.full((self.config.vna.power_sweep_length, self.config.vna.num_points), np.nan, dtype=np.complex128)

        # Create and return an instance of FluxMapData
        return FluxMapData(powers=powers, currents=currents, f=f, S=S)


    # measurements
    @Experiment.experiment_method
    def flux_map(self, live_plotting = True, vna_window = True):

        self.data = self.initialize_flux_map_data()

        self.data.start_time = datetime.datetime.now()

        if not vna_window:
            self.vna.write('SYSTem:DISPlay:UPDate OFF')

    
        # check yoko current, ramp slowly to starting value
        self.yoko.set_source_current_sweep(self.config.yoko)

        # ramp to initial current value
        self.yoko.ramp_current(self.config.yoko.currents[0], blocking=True)

        #turn current source on
        self.yoko.output(True)

        #setup sweep on VNA
        self.vna.set_sweep(self.config.vna)

        self.data.vna_meta = self.vna.meta
        
        
        #iterate over currents corresponding to different fluxes generated by the coil
        for i, current in enumerate(self.config.yoko.currents):
            #set current
            self.yoko.current(current)
            self.data.currents[i] = current
            sleep(self.config.yoko.wait)

            #take VNA trace
            f,z = self.vna.sweep()
            self.data.f = f
            self.data.S[i] = z
            
            

            #plot live data
            #self.plotter.update_pcolormesh(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
            #self.plotter.update_imshow(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
            if live_plotting:
                self.plotter.update_full_imshow(self.config.yoko.currents/1e-3, self.data.f, S_to_dBm(self.data.S[:i+1]))

            # if not vna_window:
            #     self.vna.write('SYSTem:DISPlay:UPDate ONCE')


            #save backup?
        
        self.vna.write('SYSTem:DISPlay:UPDate ON')

    @Experiment.experiment_method
    def flux_map_voltage_sweep(self, live_plotting = True, vna_window = True):

        self.data = self.initialize_flux_map_voltage_sweep_data()

        self.data.start_time = datetime.datetime.now()

        if not vna_window:
            self.vna.write('SYSTem:DISPlay:UPDate OFF')

        # check yoko current, ramp slowly to starting value
        self.yoko.set_source_voltage_sweep(self.config.yoko)

        # ramp to initial voltage value
        self.yoko.ramp_voltage(self.config.yoko.voltages[0], blocking=True)

        #turn voltage source on
        self.yoko.output(True)

        #setup sweep on VNA
        self.vna.set_sweep(self.config.vna)

        self.data.vna_meta = self.vna.meta
        
        
        #iterate over voltages corresponding to different fluxes generated by the coil
        for i, voltage in enumerate(self.config.yoko.voltages):
            #set voltage
            self.yoko.voltage(voltage)
            self.data.voltages[i] = voltage
            sleep(self.config.yoko.wait)

            #take VNA trace
            f,z = self.vna.sweep()
            self.data.f = f
            self.data.S[i] = z            

            #plot live data
            #self.plotter.update_pcolormesh(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
            #self.plotter.update_imshow(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
            if live_plotting:
                self.plotter.update_full_imshow(self.config.yoko.voltages/1e-3, self.data.f, S_to_dBm(self.data.S[:i+1]))

            # if not vna_window:
            #     self.vna.write('SYSTem:DISPlay:UPDate ONCE')


            #save backup?
        
        self.vna.write('SYSTem:DISPlay:UPDate ON')
    
    @Experiment.experiment_method
    def flux_map_constant_voltage(self, live_plotting = True, vna_window = True):

        self.data = self.initialize_flux_map_voltage_sweep_data()

        self.data.start_time = datetime.datetime.now()

        if not vna_window:
            self.vna.write('SYSTem:DISPlay:UPDate OFF')

        # check yoko current, ramp slowly to starting value
        self.yoko.set_source_voltage_sweep(self.config.yoko)

        # ramp to initial voltage value
        self.yoko.ramp_voltage(self.config.yoko.voltages[0], blocking=True)

        #turn voltage source on
        self.yoko.output(True)

        #setup sweep on VNA
        self.vna.set_sweep(self.config.vna)

        self.data.vna_meta = self.vna.meta

        #set voltage
        voltage = self.config.yoko.voltages[0]
        self.yoko.voltage(voltage)
        sleep(self.config.yoko.wait)
        
        
        #iterate over voltages corresponding to different fluxes generated by the coil
        for i, voltage in enumerate(self.config.yoko.voltages):
            

            #take VNA trace
            f,z = self.vna.sweep()
            self.data.f = f
            self.data.S[i] = z            

            #plot live data
            #self.plotter.update_pcolormesh(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
            #self.plotter.update_imshow(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
            if live_plotting:
                self.plotter.update_full_imshow(np.arange(len(self.config.yoko.voltages)), self.data.f, S_to_dBm(self.data.S[:i+1]))

            # if not vna_window:
            #     self.vna.write('SYSTem:DISPlay:UPDate ONCE')


            #save backup?
        
        self.vna.write('SYSTem:DISPlay:UPDate ON')


    @Experiment.experiment_method
    def power_sweep(self, live_plotting = True, vna_window = False):

        self.data = self.initialize_power_sweep_data()

        self.data.start_time = datetime.datetime.now()

        if not vna_window:
            self.vna.write('SYSTem:DISPlay:UPDate OFF')

        # check yoko current, ramp slowly to starting value
        self.yoko.set_source_current_sweep(self.config.yoko)

        #turn current source on
        self.yoko.output(True)

        # ramp to initial current value
        self.yoko.ramp_current(self.config.yoko.currents[0], blocking=True)

        #setup sweep on VNA
        self.vna.set_sweep(self.config.vna)

        self.data.vna_meta = self.vna.meta
        
        
        #iterate over currents corresponding to different fluxes generated by the coil
        for i, current in enumerate(self.config.yoko.currents):
            #set current
            self.yoko.current(current)
            self.data.currents[i] = current
            sleep(self.config.yoko.wait)

            for j, power in enumerate(self.config.vna.powers):
                self.config.vna.power = power
                self.vna.set_sweep(self.config.vna)
                self.data.powers[j] = power

                #take VNA trace
                f,z = self.vna.sweep()
                self.data.f = f
                self.data.S[j] = z

                if live_plotting:
                    self.plotter.update_full_imshow(self.config.vna.powers, self.data.f, S_to_dBm(self.data.S[:j+1]))


    
            
            

            #plot live data
            #self.plotter.update_pcolormesh(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
            #self.plotter.update_imshow(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
            
            # if not vna_window:
            #     self.vna.write('SYSTem:DISPlay:UPDate ONCE')


            #save backup?
        
        self.vna.write('SYSTem:DISPlay:UPDate ON')


    @Experiment.experiment_method
    def test_stuff(self):
        pass


    ### LEGACY CODE...
    def flux_map_power_dependence(self, powers, bandwidths, num_averages, vna_window=True, live_plotting=True):
        self.data_dict['powers'] = powers
        self.data_dict['bandwidths'] = bandwidths
        self.data_dict['num_averages'] = num_averages

        self.data_dict['f'] = np.full((len(self.configs_dict['yoko'].currents), len(powers), self.configs_dict['vna'].num_points), np.nan)
        self.data_dict['S'] = np.full((len(self.configs_dict['yoko'].currents), len(powers), self.configs_dict['vna'].num_points), np.nan, dtype=complex)



        self.start_experiment()

        

        if not vna_window:
            self.vna.write('SYSTem:DISPlay:UPDate OFF')

        # check yoko current, ramp slowly to starting value
        self.instruments['yoko'].set_source_current_sweep(self.configs_dict['yoko'])

        # ramp to initial current value
        self.instruments['yoko'].ramp_current(self.configs_dict['yoko'].currents[0], blocking=True)

        #turn current source on
        self.instruments['yoko'].output(True)

        self.vna.visa_instr.timeout = 10000 * 1e3

        for i, current in enumerate(self.configs_dict['yoko'].currents):
            #set current
            self.instruments['yoko'].current(current)
            print(current)

            for j, (power, bandwidth, num_average) in enumerate(zip(powers, bandwidths, num_averages)):

                self.configs_dict['vna'].power = power
                self.configs_dict['vna'].bandwidth = bandwidth
                self.configs_dict['vna'].num_averages = num_average

                print(power, bandwidth, num_average)

                #setup sweep on VNA
                self.instruments['vna'].set_sweep(self.configs_dict['vna'])            

                f,z = self.instruments['vna'].sweep()

                self.data_dict['f'][i][j] = f
                self.data_dict['S'][i][j] = z
                self.data_dict['currents'][i] = self.configs_dict['yoko'].currents[i]

                meta = self.instruments['vna'].get_meta()
                self.data_dict['meta'].append(meta)

                #plot live data
                #self.plotter.update_pcolormesh(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
                #self.plotter.update_imshow(self.data['currents'][i]/1e-3, self.data['f'][i]/1e9, np.abs(self.data['S'][i]))
                if live_plotting:
                    self.plotter.update_full_imshow(self.data_dict['powers'], self.data_dict['f'][i][j], 20*np.log(np.abs(self.data_dict['S'][i][:j+1])))

                if not vna_window:
                    self.vna.write('SYSTem:DISPlay:UPDate ONCE')

        
        self.vna.write('SYSTem:DISPlay:UPDate ON')

        self.end_experiment()


    def initialize_flux_map_adaptive_data(self):
        #make f 2d, since every trace will include different adapted frequencies
        f = np.full((self.config.yoko.sweep_length, self.config.vna.num_points), np.nan, dtype=np.float64)


    def flux_map_adaptive(self):
        raise NotImplementedError
